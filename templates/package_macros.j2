{% macro get_regex_match(classes_regex_pattern, class_name) %}{# ((( #}
{{ class_name -}}
{#
Donâ€™t overdo it. This feature is currently disabled until a real need occurs.
{% set class_regex_match = { 'pattern': '' } %}
{% for class_regex_pattern in classes_regex_pattern %}
{%   if class_name == class_regex_pattern %}
{%     set _ = class_regex_match.update({'exact_match': class_name}) %}
{%   elif class_name | match(class_regex_pattern) %}
{%     set _ = class_regex_match.update({'pattern': class_regex_pattern}) %}
{%   endif %}
{% endfor %}
{{ class_regex_match.exact_match|d(class_regex_match.pattern) -}}
#}
{%- endmacro %}{# ))) #}


{% macro gen_package_list(packages, reject_packages=[], revoke_rejected_packages=[], whitelist_packages=[], remapped_packages={}, is_present_packages_list=True) %}{# ((( #}
{% set packages__list_raw = (
                               (packages                        | list | d([]))
                          + ( ((packages__global_additional     | list | d([]))
                          +    (packages__host_group_additional | list | d([]))
                          +    (packages__host_additional       | list | d([]))
                              ) if is_present_packages_list else [])
                        ) | reject("equalto", "") | unique | list
%}
{% for condition in packages__conditional %}
{%   set _ = add_conditional_pkts(packages__list_raw, condition, 'package', remapped_packages) %}
{% endfor %}
{% for condition in packages__localizations_available %}
{%   set _ = add_conditional_pkts(packages__list_raw, condition, 'language', remapped_packages) %}
{% endfor %}
{% set packages__list = [] %}
{% for pkt in packages__list_raw %}
{%   set _ = packages__list.append(remapped_packages[pkt] | d(pkt)) %}
{% endfor %}
{% set packages__list_final = (packages__list | difference(reject_packages|difference(revoke_rejected_packages))) %}
{% if whitelist_packages %}
{%   set packages__list_final = (packages__list_final | intersect(whitelist_packages)) %}
{% endif %}
{{ packages__list_final | reject("equalto", "") | sort | unique | join('\n') }}
{%- endmacro %}{# ))) #}


{% macro add_conditional_pkts(packages__list, condition, mode, remapped_packages) %}{# ((( #}
{#
mode:

``package``
  Selection depends only on present_packages.

``language``
  Selection depends on language and present_packages.

#}
{% set found_main_package = [] %}
{% set present_packages = [] %}
{% if condition.present_packages is string %}
{%   set _ = present_packages.append(condition.present_packages) %}
{%   if condition.present_packages in packages__list %}
{%     set _ = found_main_package.append(condition.present_packages) %}
{%   endif %}
{% elif condition.present_packages is iterable %}
{%   set present_packages = condition.present_packages %}
{%   for pkt in condition.present_packages if pkt in packages__list %}
{%     set _ = found_main_package.append(pkt) %}
{%   endfor %}
{% endif %}
{% if mode == 'package' %}
{%   set _ = set_conditional_pkts(packages__list, condition, found_main_package, present_packages, mode, remapped_packages) %}
{% elif mode == 'language' %}
{%   for lang in packages__localizations %}
{%     set _ = set_conditional_pkts(packages__list, condition, found_main_package, present_packages, mode, remapped_packages, lang) %}
{%   endfor %}
{% endif %}
{%- endmacro %}{# ))) #}


{% macro set_conditional_pkts(packages__list, condition, found_main_package, present_packages, mode, remapped_packages, lang=None) %}{# ((( #}
{% if condition.require|d('all') == 'all' %}
{%   set require = present_packages|length %}
{% elif condition.require|d('all') is number %}
{%   set require = condition.require|int %}
{% endif %}
{% if (found_main_package|length and not ((require is string or require is number) and found_main_package|length < require)) %}
{%   if mode == 'package' or (mode == 'language' and condition.when|d(lang.code) == lang.code) %}
{%     if condition.additional_packages is string %}
{%       set pkt = condition.additional_packages %}
{%       set _ = packages__list.append(get_lang_pkt((remapped_packages[pkt] | d(pkt)), lang)) %}
{%     elif condition.additional_packages is iterable %}
{%       for new_pkt in condition.additional_packages %}
{%         set pkt = get_lang_pkt(get_lang_pkt((remapped_packages[new_pkt] | d(new_pkt)), lang)) %}
{%         set _ = packages__list.append(pkt) %}
{%       endfor %}
{%     endif %}
{%   endif %}
{% endif %}
{%- endmacro %}{# ))) #}


{% macro get_lang_pkt(pkt, lang) %}{# ((( #}
{% if lang is defined and lang is mapping -%}
{{   pkt|replace("LANG_NAME", lang.name)|replace("LANG_CODE", lang.code)|replace("LANG_CULTURE", lang.culture) }}
{%- else %}
{{   pkt }}
{%- endif %}
{%- endmacro %}{# ))) #}


{% macro print_comment(comment_sign) %}{# ((( #}
{% for line in packages__export_comment.split('\n') if line != 'empty' %}
{{   comment_sign }}{{ (" " + line) if (line|length) else "" }}
{# {{ comment_sign }} {{ line|wordwrap(wrapstring='\n' + comment_sign + ' ') }} #}
{% endfor %}
{%- endmacro %}{# ))) #}
